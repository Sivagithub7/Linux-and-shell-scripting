INDEXES :
========
- IT IS A DB OBJECT WHICH IS USED TO RETRIEVAL A SPECIFIC ROW FROM A
TABLE FASTLY.
- DB INDEX OBJECT WILL WORK JUST LIKE A BOOK INDEX PAGE IN TEXT
BOOKS.
BY USING BOOK INDEX PAGE WE CAN ACESS A SPECIFIC TOPIC FROM A TEXT BOOK
FASTLY SAME AS BY USING DB INDEX WE CAN ACCESS A SPECIFIC ROW FROM TABLE
FASTLY.
- BY USING INDEXES WE CAN REDUCE SEARCHING TIME AND IMPROVE THE
PERFORMANCE DATABASE.
- ON WHICH COLUMN WE CREATED AN INDEX OBJECT THAT COLUMN IS CALLED
AS "INDEXED KEY COLUMN" AND THIS INDEXED KEY COLUMN ONLY USE UNDER
"WHERE"
CLAUSE CONDITION THEN ONLY INDEXES ARE WORKING OTHERWISE INDEXES ARE
NOT WORKING ON TABLE.
- ORACLE SUPPORTING THE FOLLOWING TWO TYPES OF SEARCHING
MECHANISMS THOSE ARE,
1. TABLE SCAN
2. INDEX SCAN

1. TABLE SCAN:
=============
- IN THIS METHOD ORACLE SERVER IS SEARCHING THE ENTIRE TABLE FOR
REQUIRED DATA.
EX:

SQL> SELECT * FROM EMP WHERE SAL=3000;
SOLUTION:
==========
SAL
----------------
800
1600
1250
2975
1250
2850
2450 ---------------------------> WHERE SAL=3000 (COMPARING 14 ROWS / 14 TIMES)
3000
5000
1500
1100
950
3000
1300
2) INDEX SCAN:
==============
- IN METHOD ORACLE SERVER IS SCANNING BASED ON AN INDEXED COLUMN
WISE FOR REQUIRED DATA.
- DB INDEX OBJECTS ARE CREATED IN TWO WAYS,
i) AUTOMATICALLY (IMPLICIT INDEXES)
ii) MANUALLY(EXPLICIT INDEXES)

i) AUTOMATICALLY:
================
- WHEN WE CREATED A TABLE WITH "PRIMARY KEY / UNIQUE" CONSTRAINT
INTERNALLY SYSTEM IS CREATED A DB INDEX OBJECT ON THAT COLUMN
AUTOMATICALLY.
EX:
SQL> CREATE TABLE TEST41(EID INT PRIMARY KEY, ENAME VARCHAR2(10));
SQL> CREATE TABLE TEST42(SNO INT UNIQUE, SAL NUMBER(10));
NOTE:
=====
- IF WE WANT TO VIEW INDEX NAME ALONG WITH COLUMN NAME OF A
PARTICULAR TABLE THEN WE USE A DATADICTIONARY IS CALLED AS
"USER_IND_COLUMNS".
EX:
SQL> DESC USER_IND_COLUMNS;
SQL> SELECT COLUMN_NAME,INDEX_NAME FROM USER_IND_COLUMNS
2 WHERE TABLE_NAME='TEST41';
COLUMN_NAME INDEX_NAME
-----------------------------------------------------
---------------------------------------------------------------------------
EID SYS_C007580
SQL> SELECT COLUMN_NAME,INDEX_NAME FROM USER_IND_COLUMNS
2 WHERE TABLE_NAME='TEST42';
COLUMN_NAME INDEX_NAME
----------------------------------------------------------
----------------------------------------------------------------------
SNO SYS_C007581

ii) MANUALLY:
============
- WHEN WE CREATED AN INDEX OBJECT ON PARTICULAR COLUMN OF A TABLE
THEN WE CALLED AS "EXPLICIT INDEXES".
- USER CAN CREATE TWO TYPES OF INDEXES ARE,

1. B-TREE INDEX (DEFAULT)
> SIMPLE INDEX
> COMPSITE INDEX
> UNIQUE INDEX
> FUNCTIONAL BASED INDEX
2. BITMAP INDEX

SIMPLE INDEX:
=============
- WHEN WE CREATED AN INDEX OBJECT BASED ON A SINGLE COLUMN IN A
TBALE.

SYNTAX:
=======
CREATE INDEX <INDEX NAME> ON <TN>(COLUMN NAME);

EX:
SQL> SELECT * FROM EMP WHERE SAL=3000;
B-TREE INDEX
============
|
(LP) < | SAL = 3000 | >= (RP)
| |
(LP)<|2975|>=(RP) (LP) < | 5000 | >= (RP)
| |
2850|*,2450|*,1600|*, 3000|*,* ( * ----> ROWID )
1500|*,1300|*,1250|*,*,
1100|*, 950|*, 800|*
COMPSITE INDEX:
================
- WHEN WE CREATED AN INDEX OBJECT BASED ON MULTIPLE COLUMNS.
SYNTAX:
========
CREATE INDEX <INDEX NAME> ON <TN>(<COL1>,<COL2>,............);
NOTE:
=====
- INDEXES ARE WORKING BASED ON LEADING COLUMN WISE.
EX:
SQL> CREATE INDEX I2 ON EMP(DEPTNO,JOB);
TESTING:
SQL> SELECT * FROM EMP WHERE DEPTNO=10;--------INDEX SCAN
SQL> SELECT * FROM EMP WHERE JOB='CLERK';------TABLE SCAN
SQL> SELECT * FROM EMP WHERE DEPTNO=10 AND JOB='CLERK';------INDEX SCAN
UNIQUE INDEX:
=============
- WHEN WE CREATED AN INDEX OBJECT BASED ON "UNIQUE CONSTRAINT".
- TO RESTRICTED DUPLICATE VALUES.SO THE IT REDUCE SEARCHING TIME.
SYNTAX:
========
CREATE UNIQUE INDEX <INDEX NAME> ON <TN>(<COLUMN NAME>);
EX:
SQL> CREATE UNIQUE INDEX UI ON DEPT(DNAME);
TESTING:
SQL> INSERT INTO DEPT VALUES(50,'SALES','HYD');
ERROR at line 1:
ORA-00001: unique constraint (MYDB9AM.UI) violated
FUNCTIONAL BASED INDEX:
========================
- WHEN WE CREATE AN INDEX OBJECT BASED ON FUNCTION NAME.
SYNTAX:
=======
CREATE INDEX <INDEX NAME> ON <TN>(FUNCTION NAME(COLUMN NAME));
EX:
SQL> CREATE INDEX I3 ON EMP(UPPER(ENAME));
Index created.
SQL> SELECT * FROM EMP WHERE UPPER(ENAME)='smith';----NOT ALLOWED
SQL> SELECT * FROM EMP WHERE UPPER(ENAME)='SMITH';---ALLOWED
2. BITMAP INDEX:
===============
- CREATED ON "LOW CARDINALITY" COLUMNS IN A TABLE.
CARDINALITY:
=============
- IT REFERS THE UNIQUENESS VALUES OF A COLUMN.
SYNTAX:
========
CARDINALITY OF COLUMN = NO.OF DISTINCT VALUES IN A COLUMN
==================================
NO.OF ROWS IN TABLE
EX:
CARDINALITY OF EMPNO = 14 / 14 ----------> 1 ( >= 1 ----- HIGH CARDINALITY)
> B-TREE INDEX
CARDINALITY OF JOB = 5/14 --------------> 0.35 (<1 ------ LOW CARDINALITY )
> BITMAP INDEX
SYNTAX:
========
CREATE BITMAP INDEX <INDEX NAME> ON <TN>(COLUMN NAME);
EX:
SQL> CREATE BITMAP INDEX BIT ON EMP(JOB);
- WHEN WE CREATED A BITMAP INDEX OBJECT ON A COLUMN INTERNALLY
SYSTEM WILL ARRANGE THAT COLUMN DATA IN THE FORM OF BITMAPED INDEX
TABLE
WITH BIT NUMBERS "1" AND "0".
- HERE "1" ----------- CONDITION IS TRUE
"0" ----------- CONDIDIOTN IS FALSE
EX:
SELECT * FROM EMP WHERE JOB='PRESIDENT';
BITMAP INDEXED TABLE
|
========================================================================
=============================
JOB | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
13 | 14
========================================================================
===============================
CLERK | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
1 | 0 | 1
========================================================================
================================
PRESIDENT | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
0 | 0
========================================================================
================================
HERE "1" REPRESENTED ROWID IN A TABLE
NOTE:
=====
- TO VIEW INDEX TYPE ALONG WITH INDEX NAME OF A PARTICULAR TABLE IN
ORACLE DB THEN WE USE A DATADICTIONARY IS CALLED AS "USER_INDEXES".
EX:
SQL> DESC USER_INDEXES;
SQL> SELECT INDEX_NAME,INDEX_TYPE FROM USER_INDEXES
WHERE TABLE_NAME='EMP';
INDEX_NAME INDEX_TYPE
----------------------------------------------------
----------------------------------------------------------------------------
I1 NORMAL(B-TREE)
I2 NORMAL(B-TREE)
I3FUNCTION-BASED NORMAL(B-TREE)
BIT BITMAP
HOW TO DROP AN INDEX:
======================
SYNTAX:
========
DROP INDEX <INDEX NAME>;
EX:
DROP INDEX I1;
DROP INDEX BIT;
